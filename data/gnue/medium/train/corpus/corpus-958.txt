*** johannesV has joined #gnuenterprise
*** chillywilly has quit IRC
*** reinhard has joined #gnuenterprise
<reinhard> good morning all
*** btami has joined #gnuenterprise
*** johannesV_ has joined #gnuenterprise
<johannesV_> good morning again ...
<btami> good morning
*** johannesV has quit IRC
*** derek has quit IRC
*** chillywilly has joined #gnuenterprise
*** yure has joined #gnuenterprise
*** yure has quit IRC
<johnnyss> hi
<johannesV_> hi johnnyss
*** yure has joined #gnuenterprise
*** dimas has quit IRC
*** btami has quit IRC
*** jamest has joined #gnuenterprise
*** btami has joined #gnuenterprise
*** yure has quit IRC
*** sacha has quit IRC
*** sacha has joined #gnuenterprise
*** jcater has joined #gnuenterprise
*** siesel has joined #gnuenterprise
<siesel> hello
*** yure has joined #gnuenterprise
<jcater> hi siesek
<jcater> seisel
<siesel> jcater: how is designer improving?
<jcater> how am I progressing time-wise, or what is being added?
<siesel> Yes, both questions please.
<siesel> :)
<jcater> well, as far as changes
<jcater> it requires wx2.6 now
<jcater> so the first change was getting it stable on 2.6
<jcater> then I stopped using GNUe Form's ui drivers to draw widgets in real-time on the layout canvas
<jcater> I now draw my own objects on my own canvas object
<jcater> this gave me a tremendous amount of control over the canvas
<jcater> so things "just work" on it now
<siesel> cool, I saw this change, it looks great.
<jcater> like rubberband boxes, etc
<jcater> I also reworked the property editor
<jcater> which as it turns out
<jcater> was solely responsible for the 2+ second delay
<jcater> between clicking on a widget, and having designer actually select that widget
<jcater> actually, that will be the extent of the changes before I declare designer "stable" again
<jcater> but there's a lot of under the hood cleaning
<jcater> (comments, better variable naming, etc)
<siesel> are there any other specific features you want to integrate?
<jcater> I was trying to work through those changes before thinking about anything else
<jcater> is there something specific you're wanting to request?
<jcater> (I am using roundup now, I'm sure to reinhard's delight)
<siesel> no, not at the moment
<jcater> the main thing right now was just trying to make designer a stable, consistent experience
<siesel> I'm just thinking how to enable designer to create appserver designs
<jcater> yes, be thinking about that
<siesel> and I think this is a hugh efford
<jcater> as I do want to tackle that after I get forms support stable again
<jcater> I haven't given it any more thought other than "I want to somehow allow appserver designs"
<jcater> i.e., I haven't given any thought as to how that'd actually look
<siesel> currently I'm discussing business process design tools with a colleague
*** klasstek has joined #gnuenterprise
<siesel> I hope to  get / find  / imaging ... some ideas how to make the transform of a ideas of a non-IT guy into appserver design
<siesel> btw. I've found two designer errors, ... although you probably know both... here they are
<siesel> o.dispatchEvent('ObjectCreated')
<siesel> DB000:  AttributeError: GFBox instance has no attribute 'dispatchEvent'
<jcater> hmm
<siesel> No. 2: DB000:     newobj = _windows_.new_FileDialog(*args, **kwargs)
<siesel> DB000:  PyAssertionError: C++ assertion "wxAssertFailure" failed in ../src/common/filefn.cpp(1673): missing '|' in the wildcard string!
<jcater> can you rerun setup-cvs.py and see if you still have that error?
*** johannesV__ has joined #gnuenterprise
<siesel> No. 2 after opening a file
<jcater> okay, I wasn't aware of that second one
<jcater> but designer is in an unstable state at the moment
*** johannesV_ has quit IRC
*** johannesV__ has quit IRC
<siesel> yes, after running setup-cvs.py  the GFBox error persists
<jcater> okay
<siesel> concerning this exceptions, don't care too much.  I just want to show you, that there are gnue-designer pre-alpha tester out there :)
<jcater> okay
<jcater> actually, I'm not *that* far away from wanting alpha testers
* siesel is wondering what *that* means in terms of donuts^H^H^H^H^Hays
<siesel> ;)
*** johannesV has joined #gnuenterprise
<jcater> if I can get in a couple of solid days of programming, I think it'd be where I want it at
<jcater> of course, I had a slight disaster at my house that's now consuming my free time
<jcater> but I'm trying to make some time at work
<siesel> That's cool.
<jcater> I'm also trying to hire a 4th programmer here at work
<jcater> who, coincidentally, has several years of both python and wxPython experience
<jcater> so I hope to have him devote at least a couple of hours a week to doing some gnue work
<siesel> You don't want to work on gnue-designer yourself anymore ? :)
* jcater was shocked to find someone locally who knew python, not to mention wxPython
<jcater> sure
<jcater> and gnue-reports
<jcater> and gnue-forms
<jcater> and gnue-navigator
<jcater> :)
<siesel> seems, like everything is accelerating.
<siesel> btw. do you know a good open source project management tool ?
<siesel> I tryed planner, but read the announcement of KPlato today.
<jcater> yeah
<jcater> strange that everyone comes back all at once
<jcater> me, jamest, psu, you
<jcater> maybe it was because reinhard and johannes want to work in gnue-forms, so we realized we better get back to work!
* jcater ducks
<reinhard> lol
<jcater> it's kind of like me getting my son to clean his room
<siesel> rofl
<jcater> "Well, would you rather your dad clean you room?!? " as I grab the trash can
<jcater> s/you/your/
*** derek has joined #gnuenterprise
<siesel> night
*** siesel has quit IRC
<reinhard> is there an easier way to do this:?
<reinhard>             keyfields = {}
<reinhard>             for field in self.__primarykeyFields:
<reinhard>                 keyfields[field] = old_current[field]
<jcater> keyfields = old_current.copy()
<jcater> ?
<jcater> oh, nevermind... missed the __primarykeyfields part
<reinhard> yes
<reinhard> it should only copy a given list of keys
<jcater> not that I know of
<reinhard> ok thanks
<reinhard> ok, an issue to discuss:
<reinhard> several people (IIRC btami, kilo among others) said it would be logical if after a commit the complete result set would be queried again
<reinhard> let me search the logs
<jcater> yeah, I remember the issue
<reinhard> <reinhard> so we would have to store the last query and simply redo it
<reinhard> <kilo> yes
<reinhard> <reinhard> same would actually go after the commit
<reinhard> <reinhard> as now after commit no new records are displayed
<reinhard> now two questions
<reinhard> 1. actually the starting point was the "undo" function (that we came up with a different name afterwards), that this function should do the query again
<reinhard> it was me who extrapolated that to the commit
<reinhard> is this really desired to after commit see changes done by different users?
<reinhard> and 2. doing the complete query again after commit would mean newly inserted records being sorted to the place they belong instead of the place they were originally inserted, so it would look to the user as if the record "jumped" to a different place
<jcater> #2 was the first thing that crossed my mind when you brought this up
<reinhard> yeah and 3. what about those records that were inserted or changed in a way that they don't match the query? would they disappear after the commit?
<reinhard> will be back in 2 hours or so
<jcater> reinhard: the last query is already saved
<jcater> so you know
<jcater> as if you press the "Query" button twice, the previous query is brought back up
<jcater> my personal feeling is in several key forms, my users will get disoriented if the resultset changes on them
<jcater> but I can see where it would be useful/desirable too
<jcater> certainly it wouldn't be hard to add a requery-on-commit attribute to datasources or blocks (is there not one now?)
<jcater> but even then, the question becomes
<jcater> "what is the default?"
<jcater> I think at a minimum we should add the feature as a developer-settable option
<jcater> I'm just torn on what the default behavior should be if the setting isn't set
<reinhard> I'll leave that open for discussion
<reinhard> running away now, bbl
<jcater> re the "is there not one now?"
<jcater> I think I was thinking of the requerying each record after commit option we have on datasources
<jcater> but that is per-record, iirc, not per-resultset
<jcater> so scratch that comment
<jamest> what's the advantage to the requery of the whole result set?
<jamest> (other than it would make our record tracking and removal code go away :)
<jcater> go away, or more complicated?
<jcater> as even on requery, wouldn't you want it to still try to make a best-effort to go back to the same record
*** btami has quit IRC
<reinhard> back
<reinhard> jamest: advantage would be that you see other records that other users have added meanwhile
<reinhard> or changes from other users
<reinhard> (current requery logic only requeries those records that had changes on commit)
<jcater> the more I think about it, the more I realize that will disorient my users more times than not
<jamest> i almost wonder if that shouldn't be a separate feature
<jamest> like in postgresql's case it allows you to register for notifications of table updates
*** sjc has joined #gnuenterprise
<reinhard> as btami has gone anyway meanwhile
<reinhard> and I wanted his input on this
<reinhard> I'd be also interested in what you think about this "revert" function: should it revert to the original state of the db, or should it fetch changes from other transactions?
<reinhard> I think new records popping up on revert might not disorient as much as it would on commit
<reinhard> *sigh* why does it happen so often that I start implementing something and after that, I find out that I'm not even sure what exactly I want to implement...
<jcater> hmm
* sacha is releaved to see that happening to pros, too
<jamest> reinhard: some people claim some phase they call "design" helps with that
* jcater is unconvinced
<jamest> reinhard: but I never really understood what they were getting at
<jamest> i think the closest we got in forms to "design" was
<jamest> <jamest>hey jason, what do you think about ........
<jcater> I'm more of an Evolutionary person than an Intelligent Design
<jamest> <jcater>argh!  users!  make them stop!
<jamest> jcater is away
<jamest> <jamest>ok then, away I go
<reinhard> :)
*** sacha has quit IRC
*** johannesV has quit IRC
*** sacha has joined #gnuenterprise
*** jamest has left #gnuenterprise
<reinhard> good night all
*** reinhard has quit IRC
*** yure has quit IRC
*** klasstek has quit IRC
*** jamest has joined #gnuenterprise
*** derek has quit IRC
*** sjc has quit IRC
<jamest> question for the non-US times/date formats
<jamest> the input mask system has hard coded the time and date separators as : and / respectively
<jamest> instead of that could we get away with
<jamest> >>> import locale
<jamest> >>> locale.nl_langinfo(locale.T_FMT)
<jamest> '%H:%M:%S'
<jamest> >>> locale.nl_langinfo(locale.D_FMT)
<jamest> '%m/%d/%y'
<jamest> and simply use the first char in the string except for [%HMSmdy]
*** jcater has quit IRC
*** jamest has quit IRC
*** sacha has quit IRC
*** sacha has joined #gnuenterprise
*** sacha has quit IRC
*** derek has joined #gnuenterprise
*** derek has quit IRC
*** sacha has joined #gnuenterprise
*** sacha has quit IRC
*** sacha has joined #gnuenterprise
*** btami has joined #gnuenterprise
<btami> good morning
*** johannesV has joined #gnuenterprise
<johannesV> good morning
<btami> for the logs (re date/time formats)
<btami> >>> locale.setlocale(locale.LC_ALL, '')
<btami> 'hu_HU'
<btami> >>> locale.nl_langinfo(locale.D_FMT)
<btami> '%Y-%m-%d'
<btami> so hardcoding separators (":" and "/") not the best choice
<johannesV> hm, right ... :)
*** reinhard has joined #gnuenterprise
*** yure has joined #gnuenterprise
*** yure has quit IRC
*** yure has joined #gnuenterprise
*** btami has quit IRC
*** jamest has joined #gnuenterprise
<jamest> i saw btami posted what his date string looks like and it seems like I could get away with the first char not a date format character
<reinhard> hi jamest
<reinhard> I'm not sure if all date formats have a single date format character
<reinhard> maybe some countries have evil formats like 2006-04/13
<reinhard> (not that I would know of any)
<reinhard> jamest: I've started working on menus
<reinhard> <menu> seems to fulfill both fuctions: menu and menuitem
<reinhard> is that on purpose?
<jamest> i don't recall
<jamest> not a lot was done in menus beyond playing around
<jamest> there is a pretty complete dynamic menu system in designer fwiw
<jamest> that I was going to rip out and put into common to replace the stuff started there
<reinhard> ok, I'll have a look at that
<jamest> it only required de-caterification
<jamest> :)
<reinhard> do you remember offhand where this was in designer?
<jamest> let me look
<jamest> iirc it was in src/base
<jamest> in the MenuBar.py and IIRC ToolBar.py
<reinhard> MenuBar.py?
<jamest> i'm svn up'n now
<reinhard> found that
<reinhard> that seems to deal with the UI creation for the menu
<jamest> the only example of how it works is in designers menus
<reinhard> which leads to the question
<reinhard> does the menu handling actually belong to common or to forms?
<jamest> i think the toolbar and menu logic for setting up menus belongs in common (or gap)
<jamest> as it should be the same code in all our gui apps
<jamest> i would think
<jamest> damn, it's been to long
<jamest> base/Document.py is setting up a menu
<jamest> and shows the mru adding recently used items to the file menu
<reinhard> so exactly which part would you want to see in common?
<jamest> i think the addFoo methods built a in memory representation of a menu
<jamest> and then the finialize method mapped it to the UI widget set
<reinhard> yeah, that's how I see it, too
<jamest> what I was hoping for in common was a set of classes/methods that let us build a logical menu in memory
<jamest> like our forms
<reinhard> my understanding now would be that we have an xml structure representing the menu
<jamest> it would include methods that let us extend menus, disable items, etc
<jamest> all without using any UI widget specific code
<reinhard> and then we would somehow pass a pointer to a "uimenu" implementation into those classes?
<reinhard> so when the GCMenu is told "disable" it can call the uimenu.disable?
<jamest> yes, more or less
<jamest> or the UI would register to listen for menu update events
<jamest> then the virtual menu wouldn't need to know anything about the uimenu classes
<jamest> just emit a "disable menu uid 812"
<jamest> and the ui would get that event and say "ooooo" that's my save menu
<reinhard> hmmm
<reinhard> so we would also replace the standard menu in say forms with such classes?
<jamest> yes
<reinhard> ok
<reinhard> I see
<jamest> the reasoning is that if we do this
<jamest> then
<jamest> 1) a form could extend a menu or remove items or hide them via startup triggers
<jamest> 2) it may be possible for an application like navigator to adjust it's menu dynamically based upon the forms loaded in memory
<reinhard> ok
<reinhard> I think I got it more or less
<reinhard> as to the events vs. function calls
<reinhard> with events, we require the uimenu handler to register an event listener
<reinhard> with function calls, we require the uimenu handler to have a function "disable"
<reinhard> my experience so far is that events add complexity and eat performance
<reinhard> how strong would you feel about using events here?
<jamest> our events definately do :)
<jamest> well
<jamest> hmmmm
<jamest> originally i was thinking that events would allow the toolbar to only be links to menu entries
<jamest> so they'd hit the same events
<jamest> however things like say the google search toolbar app for IE wouldn't work in that type of environment
<jamest> so with the toolbar being separate I have to reason to stick with events :)
<jamest> er, no reason
*** jcater has joined #gnuenterprise
<jamest> but like I said, it's all jcater's fault
<jamest> (or derek's)
<jcater> I try
<jcater> (what did I do?)
<jamest> oh jcater, you're here
<jamest> um,
<jamest> we were talking about menus and I suggested reinhard look at the one in designer
<reinhard> jamest: as to linking toolbar and menu
<reinhard> I think that's a good idea
<reinhard> what about adding a "enabled" property to GTrigger?
<reinhard> then you can disable a named trigger
<reinhard> and all menu items, toobar buttons and buttons bound to that trigger could be disabled by simply disabling the trigger?
<jcater> I need to read the IRC logs
<jcater> but that seems like it could cause confusion with (new) forms designers
<reinhard> jcater: that == ?
<jcater> enabled property
<reinhard> disabling the trigger?
<reinhard> ah
<reinhard> just because of the name?
<jcater> from the standpoint of what happens if a disabled trigger is called
<jcater> does it just not run?
<jcater> throw an exception?
<reinhard> what would you think would be best?
<jcater> (not run == the calling trigger thinks it successed)
<jcater> well, I dunno
<jcater> hence the confusion :)
<jcater> I'd probably lean toward that being a developer error though
<jcater> (which would mean throwing an exception)
<reinhard> same here
<reinhard> but the main point was to allow for a single point of disabling
<jcater> right
<reinhard> everything toolbar, button, menu
<jamest> if we do that with the toolbar I think maybe it souldn't be required though
<jamest> as originally i was of the mindset that toolbar had to link to a menu item
<jamest> thus the events
<jamest> but I think it bad form now
<jamest> i think the enable/disable of a trigger would be handy
<jamest> in more than just those cases
<jamest> as you could flip optional processing on/off via a checkbox on a form via a trigger disabling another named trigger
<jamest> but in that case an exception would be unwanted
<reinhard> I wouldn't consider that clean style actually
<reinhard> I'd rather check the value of the check box in the trigger code
<jamest> ok
<jamest> makes sense
*** johannesV_ has joined #gnuenterprise
*** johannesV has quit IRC
*** yure has quit IRC
*** yure has joined #gnuenterprise
*** derek has joined #gnuenterprise
*** yure has quit IRC
*** jcater has left #gnuenterprise
*** dimas has joined #gnuenterprise
*** jcater has joined #gnuenterprise
*** klasstek has joined #gnuenterprise
*** yure has joined #gnuenterprise
*** derek has quit IRC
*** derek has joined #gnuenterprise
*** johannesV_ has quit IRC
<reinhard> jamest: the more I think about menus and toolbars, the more I see them bound rather tightly to triggers
*** sacha has quit IRC
<jcater> I may have a slightly damaged mac mini soon up for grabs
<jcater> and by "slightly" I mean, it'll have a sledge hammer in the middle of it
<reinhard> they will fire triggers, they will follow trigger's enabling/disabling
<reinhard> jcater: lol
<reinhard> ... they might even get label and help text from triggers (so a menu item and its corresponding toolbar button will get the same label/tooltip)
<reinhard> so I'm starting to think if implementation of GMenu, GMenuItem and GToolButton would feel well in the logic/ subdirectory
<reinhard> what do you think, jamest/jcater?
<jcater> fwiw, this is how designer does it
<jcater> and how I was moving forms to do it
<reinhard> is the full moon night already doing harm on my brain?
<jcater> with it's Actions
<jcater> and basically is how QT does it
<jcater> (except they all have "Events" instead of "Triggers")
<reinhard> yeah I think I remember good ol' Delphi having "Actions" where we have named triggers
<jcater> so I think having one object that represents any type of such "action" makes sense
<jamest> reinhard: and a form will be able to override a trigger to replace say the "commit" action
<reinhard> but other than that, it was the same system
<jamest> that would be handy in my case
<jcater> it also handles "hot keys"
<jcater> so Alt-F2 or the Menu option or the Toolbar icon
<jcater> are all the same object
<jcater> my only concern is are we overloading triggers too much
<jcater> do we need something that is to triggers
<jcater> like blocks are to datasources
<reinhard> I don't think so
<jcater> I'm not as convinced
<reinhard> actually I stumble over block vs. datasources issues quite often :-)
<jcater> but could be swayed
<jcater> (i.e., I don't feel so strongly about it I'm going to argue and get in any one's way :)
<reinhard> I see no need to add a GAction or something like that in between if that is what you mean
<reinhard> but then I probably don't have the same experiences as you
<jcater> that is basically what I was meaning, yes
<reinhard> so if you think something could be helpful for me to understand the potential issues
<reinhard> you see
<jcater> mine is that it seems to not be a very clean design decision moreso than it'd be hard to implement
<jcater> lots of apps have triggers
<jcater> but only forms (and maybe navigator)
<jcater> would it make sense for the menu/toolbar/ui stuff to appear
<jcater> I'm not sure if I'm making sense
<jcater> hang on .... users
<chillywilly> slap 'em
<jcater> chilly: OSHA seems to have a problem with that
<jcater> unsafe environment and all
<jcater> I told them I would wear wrist supports if I get too sore, though
<jamest> lol
<reinhard> hmmmm
<reinhard> maybe our common handling of named and event-based triggers is the confusing thing
<reinhard> not sure if I make sense either, but
<reinhard> a straightforward logic might have been
<reinhard> <action name="myproc">
<reinhard>   ... python code ...
<reinhard> </action>
<reinhard> <entry>
<reinhard>   <trigger type="ON-FOCUSOUT" action="myproc" />
<reinhard> </entry>
<reinhard> <menu>
<reinhard>   <menuitem label="do it" action="myproc" />
<reinhard> <menu>
<jcater> hmm, maybe we have different views of what a named trigger is... to me it's shared trigger code, but still a trigger
<jcater> in essence, a trigger tied to a custom event
<reinhard> ok
<reinhard> to me it was a random function called at different events
<jcater> wait
<jcater> going back to your example though
<reinhard> possibly also influenced by numerous questions asked here about "how can I call a named trigger within the python code of another trigger"
<jcater> maybe I was misunderstanding what you were after
<jcater> can you add to your example how a toolbar would be defined, if you were to define it?
<reinhard> <toolbar>
<reinhard>   <toolbutton icon="foo.jpg" action="myproc" />
<reinhard> <toolbar>
<jcater> okay, then forget I ever said anything... we are on the same wavelength
<reinhard> sure?
<jcater> what I misinterpreted you to want
<jcater> (I made too many assuptions, I guess :)
<jcater> was something like:>?
<jcater> like:
<jcater> <trigger name="mytrigger" label="Tool Label" toolbar_location="some markup" menu_location="some markup">
<jcater>    ....
<jcater> </trigger>
<jcater> which is why I was arguing against overloading the "trigger" so much
<reinhard> ah no
<reinhard> wel
<reinhard> well
<reinhard> if we ditch the <action> (which was more like a thought experiment) it would be like
<reinhard> <trigger name="mytrigger" label="Print invoice" icon="print.jpg">
<reinhard>   ... python code ...
<reinhard> </trigger>
<reinhard> <menu>
<reinhard>   <menu trigger="mytrigger" />
<reinhard>   menu trigger="othertrigger" />
<reinhard> </menu>
<reinhard> <toolbar>
<reinhard>   <toolbutton trigger="firstbuttontrigger" />
<reinhard>   <toolbutton trigger="mytrigger" />
<reinhard>   <toolbutton trigger="othertrigger" />
<reinhard> </toolbar>
<reinhard> but then again, I think I might even feel better too if the first was <action> instead of <trigger>
<reinhard> but that would possibly mean replacing the concept of named triggers by <action>s
<reinhard> could someone please slap me?
<reinhard> also we might want simple ways of doing quick'n dirty menu items like
<reinhard> <menu label="Print invoice">
<reinhard>   ... python code ...
<reinhard> </menu>
<reinhard> ?
<jcater> well
<jcater> what I would foresee
<jcater> is that menu/toolbars, etc, fire an on-action trigger
<jcater> so
<jcater> <menu label="Print Invoice">
<jcater>   <trigger action="on-action">
<jcater>    ...
<jcater> but
<jcater> <menu label="Print Invoice" action="mytrigger"/>
<jcater> would be shorthand for
<jcater> <menu label="...">
<jcater>   <trigger action="on-action" src="mytrigger"/>
<jcater> taking that philosophy gives menus/toolbars all the same functionality/options as anything else that can have a trigger assigned to it
<jcater> I wanted buttons to work the same way, but not sure if it got that far in implementation
<reinhard> and what about named triggers getting label and icon attributes?
<reinhard> that will be "inherited" by the menu items and toobar buttons?
<reinhard> do you think this is a good idea?
<jcater> I have mixed feelings
<jcater> it sure would simplify coding
<jcater> both for developers and when hand-writing XML :)
<reinhard> hmmm.... maybe decide that later
<reinhard> and what I originally wanted to ask
<reinhard> would you consider it a good idea to put this menu/toolbar handling code into gnue-common/src/logic ?
<reinhard> as the ties between menu/toolbar and triggers are rather tight
*** sjc has joined #gnuenterprise
<jcater> okay
<jcater> you've gotten my mind going in 100 different directions now
<reinhard> nice
<reinhard> so you're finally following me ;-)
<jcater> what I now wish we had done
<jcater> (and might could still do without any breakage)
<jcater> any trigger should be able to be named
<jcater> without having to be a "named" trigger
<jcater> if you take that one step further
<jcater> and trigger that doesn't have an action
<jcater> is just an unbound trigger
<jcater> a trigger that does have an action
<jcater> is a bound trigger
<jcater> since names are supposed to be unique
<jcater> in any trigger I should be able to fire any other trigger with a name by that name
<jcater> not just by using the "fireTrigger(form.block.field,'on-new-record')" (I forget how a trigger can fire another trigger on a specific object, but I know there's a way)
<jcater> but as far as how this relates to what you're talking about with menus/toolbars/actions/etc
<jcater> I'm not sure those don't deserve their own object tag/type (action?) that subclasses the same "logic" code that a trigger uses
<jcater> so you would have actions, which appear at the root level of the object
<jcater> or triggers that are code tied to events
<jcater> (even if indirectly when two events need to share the same code)
<jcater> um
<jcater> I was going somewhere with all of that
<jcater> but I forget where
<reinhard> but then, what would be the difference between a named trigger and an action?
<jcater> scope/relationship to the logical document
<jcater> implentation-wise? very little
<jcater> they'd share mostly the same code base
<reinhard> named triggers appear at the root of the document, too
<jcater> yes, but they wouldn't have to (though in most cases it would make sense)
<jcater> let me do an example
<jcater> (those speak 1,000 words)
<reinhard> ok
<jcater> (I'm just thinking outloud, btw... I hadn't given this a lot of thought)
<jcater> (writing examples is hard)
<reinhard> :)
<reinhard> thinking again
<jcater> http://www.gnuenterprise.org/~jcater/sample-trigger.txt
<jcater> (damn users... will explain in a second)
<reinhard> thinking about it... separating <trigger> and <action> is actually against the concept that "action" of a menu item is nothing more than a shortcut for an "ON-ACTIVATE" trigger
<reinhard> what is a nice umbrella term for "menus" and "toolbars"?
<jcater> user actions?
<jcater> no
<jcater> dunno
<reinhard> commanders?
<jcater> UI action elements?
<jcater> cows?
<reinhard> goats?
<jcater> reinhard: I get the feeling we're the only ones here
<jcater> crap, bbi1s
<reinhard> user_actions
<reinhard> I think that's best
<reinhard> user_actions.py
<reinhard> useractions.py
<reinhard> actions.py
<reinhard> hmmm..... now did we actually agree on *anything* afterall this discussion?
<reinhard> ... reading the backlog...
<reinhard> we agreed that we want the possibility to enable/disable triggers, which would enable/disable all buttons/toolbar buttons/menu items bound to that trigger [still pending whether that will be a trigger or an "action"]
<jamest> i'll try and catch the logs on this tonight
*** jamest has left #gnuenterprise
<reinhard> and we somehow run in circles around the question whether
<reinhard> a) a menu item has an ON-ACTIVATE trigger that is fired when the item is clicked, and that trigger is just a trigger like all other triggers, or
<reinhard> b) there are <action>s, and a menu item is bound to an action, and gets info like icon, label, help text from that action element, and an action is, while in implementation closely related to a trigger, something completely different in philosophy
<reinhard> the more I think about it the more it seems to me these are diametral concepts
<reinhard> I tend to lean towards b), as there are some conceptual differences indeed, like icon/label/helptext, possibility to enable/disable
<reinhard> and consequently buttons would be bound to an <action> rather than having an ON-ACTIVATE trigger (which would of course be supported for compatibility)
<reinhard> ---
<reinhard> ok, committed what I have so far, which is not much as I spend most of the time discussing and thinking instead of coding...
<jcater> holy crap
* jcater starts reading
<jcater> reinhard: b is what I was describing
<jcater> which, yes, is diametrically opposed to my first description of (a)
<jcater> (I should've said that earlier)
<jcater> the more I think about it
<jcater> the more I really like (b)
<jcater> it seems like a clean distiction as far as the definition of our markup
<reinhard> ok
<reinhard> I also lean towards b)
<reinhard> but I would also like to see the possibility of a trigger pointing to an action
<reinhard> and also a possibility to do "myAction.run()" in any trigger code (i.e. add actions to the global trigger namespace and give them a "run" trigger function)
<reinhard> does this still match your concept?
<jcater> definitely
<reinhard> excellent
<reinhard> I think we are on the same page then
<reinhard> and I will move forward in that direction
<jcater> reinhard: but you realize in a week I will have changed my mind again, right?
<reinhard> :)
<jcater> reinhard... this is completely off the subject
<jcater> and I'm sure it's been discussed ad nauseum while I was preoccupied with work
<jcater> but how far are we featurewise from considering a 1.0 release?
<jcater> forms is getting a lot of work by you and johannes, so obviously that would need to happen first
<jcater> I only ask because I see so many projects where our 0.6 is comparable to their 1.6 or even 2.6
<jcater> I'm not sure if I care if we ever make it to 1.0, since as a developer it doesn't affect me on whether I'm using it or not
<reinhard> there is one psychological thing here for me
<reinhard> as long as we are 0.x I feel like having the right to break compatibility
<reinhard> as soon as we are 1.0 I think we morally have the obligation to stay compatible with every single feature or misfeature that is in the code
<reinhard> I seriously would like to see a 0.9 or comparable being in use for > 6 months without much happening
<reinhard> so we know it's stable enough
<reinhard> stable as in "no bugs" and stable as in "no features about to be added that would break things"
<reinhard> but then again, I've always taken a highly conservative approach on such things
<jcater> okay
*** yure has quit IRC
<reinhard> good night all
*** reinhard has quit IRC
*** jcater has quit IRC
*** jamest has joined #gnuenterprise
*** bigbrother_ has joined #gnuenterprise
*** chillywilly has quit IRC
*** derek has quit IRC
*** klasstek has quit IRC
*** ajmitch has quit IRC
*** nickr has quit IRC
*** bigbrother has quit IRC
*** ncjp has quit IRC
*** bigbrother` has quit IRC
*** derek has joined #gnuenterprise
*** klasstek has joined #gnuenterprise
*** chillywilly has joined #gnuenterprise
*** ajmitch has joined #gnuenterprise
*** bigbrother has joined #gnuenterprise
*** ncjp has joined #gnuenterprise
*** nickr has joined #gnuenterprise
*** bigbrother` has joined #gnuenterprise
*** chillywilly has quit IRC
*** klasstek has quit IRC
*** ajmitch has quit IRC
*** nickr has quit IRC
*** derek has quit IRC
*** bigbrother` has quit IRC
*** bigbrother has quit IRC
*** ncjp has quit IRC
*** derek has joined #gnuenterprise
*** klasstek has joined #gnuenterprise
*** chillywilly has joined #gnuenterprise
*** ajmitch has joined #gnuenterprise
*** bigbrother has joined #gnuenterprise
*** ncjp has joined #gnuenterprise
*** nickr has joined #gnuenterprise
*** bigbrother` has joined #gnuenterprise
*** chillywilly has quit IRC
*** klasstek has quit IRC
*** ajmitch has quit IRC
*** nickr has quit IRC
*** derek has quit IRC
*** bigbrother` has quit IRC
*** bigbrother has quit IRC
*** ncjp has quit IRC
*** derek has joined #gnuenterprise
*** klasstek has joined #gnuenterprise
*** chillywilly has joined #gnuenterprise
*** ajmitch has joined #gnuenterprise
*** bigbrother has joined #gnuenterprise
*** ncjp has joined #gnuenterprise
*** nickr has joined #gnuenterprise
*** bigbrother` has joined #gnuenterprise
*** chillywilly has quit IRC
*** chillywilly has joined #gnuenterprise
*** sjc has quit IRC
*** derek has quit IRC
*** derek has joined #gnuenterprise
*** klasstek has quit IRC
*** jamest has quit IRC
*** klasstek has joined #gnuenterprise
*** klasstek has quit IRC
*** reinhard has joined #gnuenterprise
<reinhard> good morning all
*** johannesV has joined #gnuenterprise
<johannesV> good morning
*** btami has joined #gnuenterprise
<btami> good morning
<johannesV> hi btami
<reinhard> hi btami
<reinhard> did you see our discussion from the day before yesterday about requery after commit?
*** yure has joined #gnuenterprise
<btami> reinhard: yes, but can't remember if there was any conclusion
<reinhard> yes, that's right
<reinhard> actually I was hoping for your input
<btami> i can summarize my complaints
<johannesV> bbk
<johannesV> erm
<johannesV> bbl
<btami> i mean complaints of our employee
<reinhard> first question is
<btami> but i have start from the beginning
<reinhard> is the requery only wanted after a rollback, or also after a commit?
<btami> hmm, i had no time to think about it
<btami> let me describe our situation first
<reinhard> ok
<btami> we have an old dos based (foxpro) payroll app
<btami> it works with only some hundreds of peops data in most cases
<btami> so, all of my forms starts with all data opened
<btami> something similar as prequery="Y" for all datasources
<btami> and all form has two F keys
<btami> one for browse, and one for seek 1 record by a key (name, etc.)
<btami> all modification is happening on 1 record at a time
<btami> after user modifies something, he can save or escape
<btami> so
<btami> in a new gnue based inhouse form
<btami> the "clear form" button is misleading her
<btami> koz she thinks it only will undo only the form she modified right now
<btami> this was 1. complaint
<btami> th 2. is
<btami> after pressing this button, koz she did something wrong
<btami> she lose prequery='Y' and the current record she worked on
<btami> was this understandable ?
<reinhard> yes
<btami> ok :)
<reinhard> both issues are actually related to the "undo" function, and not to commit in any way
<btami> yes
<reinhard> so commit behaviour could stay as it is now?
<btami> i think so
<reinhard> because at the original discussion we disgressed into thinking that after commit, changes from the backend should be refreshed
<reinhard> and thinking more about this, it seemed a bad idea
<btami> yep
<reinhard> so the question is
<reinhard> would the "undo" function revert to the state of the result set before any change was made
<reinhard> or should it refresh data from the backend
<reinhard> risking that, for example, the current record suddenly disappears because another user has just deleted it
<reinhard> or records "jumping around" because somebody changed a record in a way relevant for the sort order
<btami> seems the former is a bit better
<reinhard> ok, I think this is something that would also fit jcater's and jamest's concepts
<reinhard> but we might want to sleep over it once again :)
<btami> you mean "undo" will take him to the state where he was after last "save" , arn'n you?
<reinhard> right
<btami> ok, cool
<reinhard> or after the last query, whatever was last
<btami> yep
*** yure has quit IRC
*** btami has quit IRC
*** lupo__ has joined #gnuenterprise
*** jamest has joined #gnuenterprise
*** jcater has joined #gnuenterprise
<reinhard> bbl
*** reinhard has quit IRC
*** johannesV has quit IRC
*** johannesV has joined #gnuenterprise
*** btami has joined #gnuenterprise
*** klasstek has joined #gnuenterprise
<jamest> reinhard: I saw the unsed import commits
<jamest> if you're not using pylint yet, i'd suggest it as it catches those
*** derek has joined #gnuenterprise
*** sjc has joined #gnuenterprise
*** SachaS has joined #gnuenterprise
*** reinhard has joined #gnuenterprise
<reinhard> do we have a decent configuration for pylint?
<reinhard> seeing my fresh and beautiful actions.py rated with -40/10 makes me feel depressed ;-)
<reinhard> wow
<reinhard> I like this :)
<jamest> yes
<jamest> i have one at home
<reinhard> ok
<jamest> there are only a few edits
<reinhard> for example I would like to not require docstrings for __xxxx functions
<jamest> do you have a .pylintrc file in $HOME
<reinhard> and if possible it should accept u_(), _(), gDebug() et al
<jamest> do you have a .pylintrc file in $HOME :)
<reinhard> nope
<jamest> hmmmm
<reinhard> I used pylint for the first time now
<jamest> do
<jamest> pylint --generate-rcfile
<reinhard> would be nice if you could commit your .pylintrc in common/utils
<jamest> it's 2 edits atm
<jamest> iirc
<jamest> in [REPORTS]
<jamest> # Include message's id in output
<jamest> include-ids=yes
<jamest> in [VARIABLES]
<jamest> additional-builtins=u_,gDebug,gConfig
<reinhard> ok
<jamest> that should do it
<jamest> as for the """""" on __XXXX functoins
<jamest> I'd be tempted to just do a one liner
<jamest> as I assume you're talking __get__ type things?
<reinhard> no
<reinhard> they are already excluded
<jamest> or __call__
<reinhard> no-docstring-rgx=__.*__
<jamest> that msg-id on thing is nice
<reinhard> I consider purely local functions (like __foo()) as non-docstringy
<reinhard> I changed it to
<reinhard> no-docstring-rgx=__.*
<jamest> as you can go to
<jamest> http://www.logilab.org/projects/pylint/documentation/features
<jamest> and get notes on why it flagged it
<jamest> also, in the masks stuff
<jamest> i've started doing things like
<jamest> # Copyright 2001-2006 Free Software Foundation
<jamest> #
<jamest> # pylint: disable-msg=R0903,
<jamest> #  R0903 disabled as these classes represent placeholders and
<jamest> #  as such don't have public methods
<jamest> as that's per module disable of pylint msgs
<jamest> disable-msg=R0903,C0103,ETC010
<reinhard> nice
<jamest> i figured we'd disable the msgs we were ok with in that module then occasionally replace the
<jamest> # pylint: disable-msg=R0903,
<jamest> with
<jamest> # pylint: enable-msg=R0903,
<jamest> and verify that the warnings are all what is expected
<jamest> then re-disable it
<jamest> i really like pylint
<jamest> it catches errors that would be a bear otherwise
<jamest> the only bad think about that disable of doc strings
<jamest> thing
<jamest> for me it's a great reminder that a method doesn't have a comment describing function
<reinhard> I have a question about GTriggerCore
<reinhard> there are reqirements to an object so it can have triggers attached
<reinhard> and there are other requirements so the objects can be visible in the trigger namespace
<reinhard> AFACT both things are implemented in GTriggerCore
<reinhard> is there any reason why this is not separated?
<reinhard> as there might be objects that can be seen in a trigger, but can't have a trigger themselves (for example a menu item, a toolbar, a label...)
<reinhard> oh.....
<reinhard> I just noticed that "can have triggers attached" would actually be GTriggerExtension
<reinhard> so I don't understand why _localTriggerNamespace and _validTriggers are defined in GTriggerCore instead of GTriggerExtension
<jamest> they should be 2 classes
<jamest> i thought they were two
<jamest> eh, wait, you said that at the bottom didn't you :)
<reinhard> jamest: just read the last two lines from me :)
<reinhard> yes
<jamest> is the localTriggerNamespace the namespace from that instance down?
<jamest> at one time i think we could attach a triger to something (say a block)
<jamest> and self == ref to block
<jamest> self.field == ref to field in that block
<jamest> however I think this broken years before i went MIA
<reinhard> this is exactly that
<reinhard> AFAICT
<reinhard> and so it would only make sense for objects that you *can* actually attach a trigger to
<reinhard> I mean
<reinhard> I could do the standard gnue evolutionary way: change it and look who screams
<reinhard> but I figured I'd ask before :)
<jamest> i would think so
<reinhard> ok
*** chillywilly has quit IRC
<reinhard> another question
*** chillywilly has joined #gnuenterprise
<reinhard> each object in the trigger namespace has a _parent property
<reinhard> do you make use of that in any way?
<jamest> in my triggers?
<jamest> no
<jamest> i believe i always use absolute reference from form.
<jamest> form.block.field
<reinhard> ok
<reinhard> I figure that you also don't make use of the _object property of trigger objects that let you directly access the GObj object that should actually be hidden behind it
<jamest> i do not
<jamest> i *think* that was added for papo folks
<jamest> and was a horrible, horrible idea
<reinhard> ok
<reinhard> so you agree with removing it again
<jamest> yes
<reinhard> good
<jamest> i see the trigger namespace as ideally being
<jamest> a restricted python environment with control over imports (not implemented and not sure if possible since we do javascript to IIRC)
<jamest> having no access to the GObjs, only to instances of the class that implements the namespace representation of that object in the trigger
<jamest> damn, could i have said that any more complicated
<reinhard> I think I understand, and I agree with that concept
<jamest> there is a class that maps a var name in the trigger to an object
<jamest> and controlls access to that object via the exposed properties
<reinhard> right
<jamest> methods, etc
<reinhard> that's GObjNamespace
<jamest> that was to hide/protect the GObj based instances
<reinhard> exactly the class I'm cleaning up, pep8ifying etc. right now
<reinhard> :)
<reinhard> thus all these questions
<jamest> :)
<jamest> so out of curiosity, did you get above the -40 in pylint :)
<reinhard> yes
<reinhard> it was mostly about undefined u_
<jamest> it's always depressing to hit those
<jamest> also, i'm not sure if it's good form
<jamest> but I started doing
<jamest> __revision__ = "$Id$"
<jamest> to get rid of that warning
<jamest> about the missing __revision__
<reinhard> I have actions.py with only a few warnings left that I can't do anything about because they are based in the abstract base classes
<reinhard> I removed the __revision__ from my .pylintrc :-)
<reinhard> and added __all__ instead
<reinhard> which I really consider useful to have
<jamest> what's __all__?
* jamest recalls using it in __init__.py files at times
<reinhard> documents what will go into "from foo import *"
<reinhard> let me explain
<reinhard> if you have foo.py:
<reinhard> from bar import baz
<reinhard> def frob():
<reinhard>   pass
<reinhard> ----
<reinhard> and then somewhere you do
<reinhard> from foo import *
<reinhard> it does not only import frob but also baz
<reinhard> because baz is in foo's global namespace because of the import
<reinhard> but if you have in foo.py an additional line
<reinhard> __all__ = ['frob']
<reinhard> from foo import * will only import frob
<reinhard> err I think that was a rather complicated explanation :)
<jamest> no, i got it, we've used it in common, i just haven't needed in a while
<jamest> so I followed
*** johannesV has quit IRC
*** btami has quit IRC
*** jamest_ has joined #gnuenterprise
*** jamest has quit IRC
<reinhard> I'm now trying to understand what __properties__ is all about in triggers
<reinhard> is it correct that I must do
<reinhard> form.myBlock.__properties__.editable = True
<reinhard> instead of
<jamest_> iirc it was too allow you to set certain things
<reinhard> form.myBlock.editable = True?
<jamest_> yes
<jamest_> it's poorly named
<jamest_> but we were trying to avoid a namespace issue
<reinhard> and that's done because I could be unlucky and have a field in that block with the name "editable"?
<jamest_> right
<jamest_> but there are better ways i'd imagine
<jamest_> .setProperty('prop',value)
<reinhard> I'm not sure I can think of any
<jamest_> or
<jamest_> setProperty(form.block.field, property, value)
<reinhard> hmmm
<reinhard> is this __properties__ in use at all?
<jamest_> in a demo trigger somewhere :)
<reinhard> so we could dare break it?
<jamest_> i would think so
<reinhard> actually
<reinhard> hmmm.....
<reinhard> I would prefer going to the most intuitive
<reinhard> form.myBlock.editable = True
<reinhard> because with the same argument, we could also say it's a problem that no block may have a field named "gotoRecord"
<reinhard> because form.myBlock.gotoRecord is a function
<jcater> and I like to name stuff __
<jcater> __<something>__ too!
<jamest_> jcater __a__, __x__, __j__
<jamest_> __q__
<reinhard> so what do you think?
<jamest_> i think i'm ok with direct access
<reinhard> ok
*** jamest_ has quit IRC
*** lupo__ has quit IRC
*** sjc has quit IRC
<reinhard> good night all
*** reinhard has quit IRC
*** klasstek has quit IRC
*** derek has quit IRC
